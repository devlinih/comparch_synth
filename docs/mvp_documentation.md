---
fontsize: 12pt
geometry: margin=1in
colorlinks: true
urlcolor: blue
figPrefix:
    - "Figure"
    - "Figures"
tblPrefix:
    - "Table"
    - "Tables"
lstPrefix:
    - "Listing"
    - "Listings"
eqnPrefix:
    - "Equation"
    - "Equations"
codeBlockCaptions: true
---


# Digital Synthesizer - MVP

Devlin Ih and Neel Dhulipala

## Overview


## Audio PWM Generator

The `audio_pwm_generator` module takes in our 12 bit audio signal and modulates
it out as a 1-bit PWM signal. Its input ports are are `[11:0] audio`, `clk`,
`rst`, and `ena`. Its output port is `pwm_out`.

`audio_pwm_geneator` modulates the output by making a greater than comparison
to a 12-bit counter.

We improved the quality of the PWM signal with a simple trick found in this
[blog post](https://zipcpu.com/dsp/2017/09/04/pwm-reinvention.html): reversing
the bits in the counter to generate the PWM signal. This improves the spacing
of the pulses. This is best illustrated with an example. Luckily, [@tbl:pwm]
has an example of a 3 bit sample PWM module with a sample of `3'b100`.

| `counter` | `out` | `counter_rev` | `out_rev` |
|-----------|-------|---------------|-----------|
| `000`     | `1`   | `000`         | `1`       |
| `001`     | `1`   | `100`         | `0`       |
| `010`     | `1`   | `010`         | `1`       |
| `011`     | `0`   | `110`         | `0`       |
| `100`     | `0`   | `001`         | `1`       |
| `101`     | `0`   | `101`         | `0`       |
| `110`     | `0`   | `011`         | `0`       |
| `111`     | `0`   | `111`         | `0`       |

: Table showing PWM generator with a sample of `3'b100`. Both the counter and
  reversed counter have the same number of high output cycles, but the reversed
  counter has more distribution among the pulses. {#tbl:pwm}

The PWM module takes a 12-bit sample from the `audio` port every 272 clock
cycles. With a clock frequency of 12MHz, this yields a sample rate of
$12000000/272 \approx 44.1kHz$, twice the highest pitch a human can hear.

You might be wondering how we can modulate a 12-bit sample in 272 clock cycles.
The answer is, we can't. However, due the reversed counter, the output becomes
a $\log_2(272) \approx 8.09$ bit approximation of the 12-bit sample.

## Channel

The `channel` module is responsible for generating waveforms and adding effects
to them. Its inputs are `clk`, `ena`, `rst`, `[11:0] pitch`, and `[1:0]
waveform`. Its output is `[10:0] out`.

**During a reset, the `channel` module needs 2 additional `clk` cycles after
`rst` goes low to fully reset.**

`channel` is able to select between 4 different waveforms, shown in
[@tbl:waveforms]. It can generate frequencies in the from 5.7Hz to 23437.5Hz.
the frequency generated is controlled from the `[11:0] pitch` input (0--4095)
and is modeled by [@eq:frequency].

| `[1:0] waveform` | Waveform |
|------------------|----------|
| `00`             | Square   |
| `01`             | Triangle |
| `10`             | Sine     |
| `11`             | Sawtooth |

: Table showing waveform generated by channel based on `waveform` select input. {#tbl:waveforms}

$$ f(x) = \frac{12MHz}{2 \cdot 256 \cdot (x+1)} $$ {#eq:frequency}

The `channel` module contains an 8-bit counter. The counter increments at a
rate defined by the [`clock_divider`]({#sec:clock_divider}) module and `pitch`.
Its value represents the sample number of an 8-bit sample, which is fed into
one of 4 [waveform generator]({#sec:wave_generators}).

### Clock Divider {#sec:clock_divider}

The `clock_divider` module exists to slow the clock signal by a specified
amount for generating audio waveforms. Its inputs are `clk`, `rst`, and `7:0
divide` and its output is `clk_divided`.

`clock_divider` outputs a clock at a frequency defined by:

$$ \text{output freq} = \frac{\text{input freq}}{2 (divide+1)} $$

### Wave Generators {#sec:wave_generators}

Each wave generator is a combinational logic block that takes an 8-bit input
(from a `channel`s period counter) and outputs an 11-bit value representing a
waveform's sample.

`sq_wave_generator` outputs a square wave with the following CL:

```systemverilog
always_comb square = (period[7]) ? -1 : 11'b0;
```

Alternatively, you could extend the most significant bit of the input instead
of muxing it.

`tri_wave_generator` outputs a triangle wave with the following CL:

```systemverilog
always_comb begin
   triangle = period[7] ? {~period[6:0], ~{4{period[0]}}}
                        : { period[6:0],  {4{period[0]}}};
end
```

`sine_wave_generator` outputs a sine wave from a lookup table defined as giant
`case` statement.

`saw_wave_generator` outputs a sawtooth wave with the following CL:

```systemverilog
always_comb saw = {period, {3{period[0]}}};
```

## Debouncing


## Monostable

